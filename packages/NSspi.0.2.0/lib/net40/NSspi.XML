<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NSspi</name>
    </assembly>
    <members>
        <member name="T:NSspi.ByteWriter">
            <summary>
            Reads and writes value types to byte arrays with explicit endianness.
            </summary>
        </member>
        <member name="M:NSspi.ByteWriter.WriteInt16_BE(System.Int16,System.Byte[],System.Int32)">
            <summary>
            Writes a 2-byte signed integer to the buffer in big-endian format.
            </summary>
            <param name="value">The value to write to the buffer.</param>
            <param name="buffer">The buffer to write to.</param>
            <param name="position">The index of the first byte to write to.</param>
        </member>
        <member name="M:NSspi.ByteWriter.WriteInt32_BE(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Writes a 4-byte signed integer to the buffer in big-endian format.
            </summary>
            <param name="value">The value to write to the buffer.</param>
            <param name="buffer">The buffer to write to.</param>
            <param name="position">The index of the first byte to write to.</param>
        </member>
        <member name="M:NSspi.ByteWriter.ReadInt16_BE(System.Byte[],System.Int32)">
            <summary>
            Reads a 2-byte signed integer that is stored in the buffer in big-endian format.
            The returned value is in the native endianness.
            </summary>
            <param name="buffer">The buffer to read.</param>
            <param name="position">The index of the first byte to read.</param>
            <returns></returns>
        </member>
        <member name="M:NSspi.ByteWriter.ReadInt32_BE(System.Byte[],System.Int32)">
            <summary>
            Reads a 4-byte signed integer that is stored in the buffer in big-endian format.
            The returned value is in the native endianness.
            </summary>
            <param name="buffer">The buffer to read.</param>
            <param name="position">The index of the first byte to read.</param>
            <returns></returns>
        </member>
        <member name="T:NSspi.Contexts.ClientContext">
            <summary>
            Represents a client security context. Provides the means to establish a shared security context
            with the server and to encrypt, decrypt, sign and verify messages to and from the server.
            </summary>
            <remarks>
            A client and server establish a shared security context by exchanging authentication tokens. Once
            the shared context is established, the client and server can pass messages to each other, encrypted,
            signed, etc, using the established parameters of the shared context.
            </remarks>
        </member>
        <member name="M:NSspi.Contexts.ClientContext.#ctor(NSspi.Credentials.Credential,System.String,NSspi.Contexts.ContextAttrib)">
            <summary>
            Initializes a new instance of the ClientContext class. The context is not fully initialized and usable
            until the authentication cycle has been completed.
            </summary>
            <param name="cred">The security credential to authenticate as.</param>
            <param name="serverPrinc">The principle name of the server to connect to, or null for any.</param>
            <param name="requestedAttribs">Requested attributes that describe the desired properties of the
            context once it is established. If a context cannot be established that satisfies the indicated
            properties, the context initialization is aborted.</param>
        </member>
        <member name="M:NSspi.Contexts.ClientContext.Init(System.Byte[],System.Byte[]@)">
             <summary>
             Performs and continues the authentication cycle.
             </summary>
             <remarks>
             This method is performed iteratively to start, continue, and end the authentication cycle with the
             server. Each stage works by acquiring a token from one side, presenting it to the other side
             which in turn may generate a new token.
            
             The cycle typically starts and ends with the client. On the first invocation on the client,
             no server token exists, and null is provided in its place. The client returns its status, providing
             its output token for the server. The server accepts the clients token as input and provides a
             token as output to send back to the client. This cycle continues until the server and client
             both indicate, typically, a SecurityStatus of 'OK'.
             </remarks>
             <param name="serverToken">The most recently received token from the server, or null if beginning
             the authentication cycle.</param>
             <param name="outToken">The clients next authentication token in the authentication cycle.</param>
             <returns>A status message indicating the progression of the authentication cycle.
             A status of 'OK' indicates that the cycle is complete, from the client's perspective. If the outToken
             is not null, it must be sent to the server.
             A status of 'Continue' indicates that the output token should be sent to the server and
             a response should be anticipated.</returns>
        </member>
        <member name="T:NSspi.Contexts.Context">
            <summary>
            Represents a security context and provides common functionality required for all security
            contexts.
            </summary>
            <remarks>
            This class is abstract and has a protected constructor and Initialize method. The exact
            initialization implementation is provided by a subclasses, which may perform initialization
            in a variety of manners.
            </remarks>
        </member>
        <member name="M:NSspi.Contexts.Context.#ctor(NSspi.Credentials.Credential)">
            <summary>
            Performs basic initialization of a new instance of the Context class.
            Initialization is not complete until the ContextHandle property has been set
            and the Initialize method has been called.
            </summary>
            <param name="cred"></param>
        </member>
        <member name="P:NSspi.Contexts.Context.Initialized">
            <summary>
            Whether or not the context is fully formed.
            </summary>
        </member>
        <member name="P:NSspi.Contexts.Context.Credential">
            <summary>
            The credential being used by the context to authenticate itself to other actors.
            </summary>
        </member>
        <member name="P:NSspi.Contexts.Context.ContextHandle">
            <summary>
            A reference to the security context's handle.
            </summary>
        </member>
        <member name="P:NSspi.Contexts.Context.AuthorityName">
            <summary>
            The name of the authenticating authority for the context.
            </summary>
        </member>
        <member name="P:NSspi.Contexts.Context.ContextUserName">
            <summary>
            The logon username that the context represents.
            </summary>
        </member>
        <member name="P:NSspi.Contexts.Context.Expiry">
            <summary>
            The UTC time when the context expires.
            </summary>
        </member>
        <member name="P:NSspi.Contexts.Context.Disposed">
            <summary>
            Whether the context has been disposed.
            </summary>
        </member>
        <member name="M:NSspi.Contexts.Context.Initialize(System.DateTime)">
            <summary>
            Marks the context as having completed the initialization process, ie, exchanging of authentication tokens.
            </summary>
            <param name="expiry">The date and time that the context will expire.</param>
        </member>
        <member name="M:NSspi.Contexts.Context.Dispose">
            <summary>
            Releases all resources associated with the context.
            </summary>
        </member>
        <member name="M:NSspi.Contexts.Context.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with the context.
            </summary>
            <param name="disposing">If true, release managed resources, else release only unmanaged resources.</param>
        </member>
        <member name="M:NSspi.Contexts.Context.Encrypt(System.Byte[])">
            <summary>
            Encrypts the byte array using the context's session key.
            </summary>
            <remarks>
            The structure of the returned data is as follows:
             - 2 bytes, an unsigned big-endian integer indicating the length of the trailer buffer size
             - 4 bytes, an unsigned big-endian integer indicating the length of the message buffer size.
             - 2 bytes, an unsigned big-endian integer indicating the length of the encryption padding buffer size.
             - The trailer buffer
             - The message buffer
             - The padding buffer.
            </remarks>
            <param name="input">The raw message to encrypt.</param>
            <returns>The packed and encrypted message.</returns>
        </member>
        <member name="M:NSspi.Contexts.Context.Decrypt(System.Byte[])">
            <summary>
            Decrypts a previously encrypted message.
            </summary>
            <remarks>
            The expected format of the buffer is as follows:
             - 2 bytes, an unsigned big-endian integer indicating the length of the trailer buffer size
             - 4 bytes, an unsigned big-endian integer indicating the length of the message buffer size.
             - 2 bytes, an unsigned big-endian integer indicating the length of the encryption padding buffer size.
             - The trailer buffer
             - The message buffer
             - The padding buffer.
            </remarks>
            <param name="input">The packed and encrypted data.</param>
            <returns>The original plaintext message.</returns>
        </member>
        <member name="M:NSspi.Contexts.Context.MakeSignature(System.Byte[])">
            <summary>
            Signs the message using the context's session key.
            </summary>
            <remarks>
            The structure of the returned buffer is as follows:
             - 4 bytes, unsigned big-endian integer indicating the length of the plaintext message
             - 2 bytes, unsigned big-endian integer indicating the length of the signture
             - The plaintext message
             - The message's signature.
            </remarks>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NSspi.Contexts.Context.QuerySessionKey">
            <summary>
            Returns the Session Key from a context or null on failure.
            </summary>
            <remarks>
            Session keys are sometimes needed for other purposes or HMAC functions. This function
            will run QueryAttribute to get the session key struct, and read and return the key from
            that struct.
            </remarks>
            <returns>byte[] with the session key data or null on failure</returns>
        </member>
        <member name="M:NSspi.Contexts.Context.VerifySignature(System.Byte[],System.Byte[]@)">
            <summary>
            Verifies the signature of a signed message
            </summary>
            <remarks>
            The expected structure of the signed message buffer is as follows:
             - 4 bytes, unsigned integer in big endian format indicating the length of the plaintext message
             - 2 bytes, unsigned integer in big endian format indicating the length of the signture
             - The plaintext message
             - The message's signature.
            </remarks>
            <param name="signedMessage">The packed signed message.</param>
            <param name="origMessage">The extracted original message.</param>
            <returns>True if the message has a valid signature, false otherwise.</returns>
        </member>
        <member name="M:NSspi.Contexts.Context.QueryBufferSizes">
            <summary>
            Queries the security package's expections regarding message/token/signature/padding buffer sizes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSspi.Contexts.Context.QueryContextString(NSspi.Contexts.ContextQueryAttrib)">
            <summary>
            Queries a string-valued context attribute by the named attribute.
            </summary>
            <param name="attrib">The string-valued attribute to query.</param>
            <returns></returns>
        </member>
        <member name="M:NSspi.Contexts.Context.CheckLifecycle">
            <summary>
            Verifies that the object's lifecycle (initialization / disposition) state is suitable for using the
            object.
            </summary>
        </member>
        <member name="T:NSspi.Contexts.ContextAttrib">
            <summary>
            Defines options for creating a security context via win32 InitializeSecurityContext
            (used by clients) and AcceptSecurityContext (used by servers).
            Required attribute flags are specified when creating the context. InitializeSecurityContext
            and AcceptSecurityContext returns a value indicating what final attributes the created context
            actually has.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.Zero">
            <summary>
            No additional attributes are provided.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.Delegate">
            <summary>
            The server can use the context to authenticate to other servers as the client. The
            MutualAuth flag must be set for this flag to work. Valid for Kerberos. Ignore this flag for
            constrained delegation.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.MutualAuth">
            <summary>
            The mutual authentication policy of the service will be satisfied.
            *Caution* - This does not necessarily mean that mutual authentication is performed, only that
            the authentication policy of the service is satisfied. To ensure that mutual authentication is
            performed, query the context attributes after it is created.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.ReplayDetect">
            <summary>
            Detect replayed messages that have been encoded by using the EncryptMessage or MakeSignature
            message support functionality.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.SequenceDetect">
            <summary>
            Detect messages received out of sequence when using the message support functionality.
            This flag implies all of the conditions specified by the Integrity flag - out-of-order sequence
            detection can only be trusted if the integrity of any underlying sequence detection mechanism
            in transmitted data can be trusted.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.Confidentiality">
            <summary>
            The context must protect data while in transit. Encrypt messages by using the EncryptMessage function.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.UseSessionKey">
            <summary>
            A new session key must be negotiated.
            This value is supported only by the Kerberos security package.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.AllocateMemory">
            <summary>
            The security package allocates output buffers for you. Buffers allocated by the security package have
            to be released by the context memory management functions.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.Connection">
            <summary>
            The security context will not handle formatting messages. This value is the default for the Kerberos,
            Negotiate, and NTLM security packages.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.InitExtendedError">
            <summary>
            When errors occur, the remote party will be notified.
            </summary>
            <remarks>
            A client specifies InitExtendedError in InitializeSecurityContext
            and the server specifies AcceptExtendedError in AcceptSecurityContext.
            </remarks>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.AcceptExtendedError">
            <summary>
            When errors occur, the remote party will be notified.
            </summary>
            <remarks>
            A client specifies InitExtendedError in InitializeSecurityContext
            and the server specifies AcceptExtendedError in AcceptSecurityContext.
            </remarks>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.InitStream">
            <summary>
            Support a stream-oriented connection. Provided by clients.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.AcceptStream">
            <summary>
            Support a stream-oriented connection. Provided by servers.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.InitIntegrity">
            <summary>
            Sign messages and verify signatures by using the EncryptMessage and MakeSignature functions.
            Replayed and out-of-sequence messages will not be detected with the setting of this attribute.
            Set ReplayDetect and SequenceDetect also if these behaviors are desired.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.AcceptIntegrity">
            <summary>
            Sign messages and verify signatures by using the EncryptMessage and MakeSignature functions.
            Replayed and out-of-sequence messages will not be detected with the setting of this attribute.
            Set ReplayDetect and SequenceDetect also if these behaviors are desired.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.InitManualCredValidation">
            <summary>
            An Schannel provider connection is instructed to not authenticate the server automatically.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextAttrib.InitUseSuppliedCreds">
            <summary>
            An Schannel provider connection is instructed to not authenticate the client automatically.
            </summary>
        </member>
        <member name="T:NSspi.Contexts.ContextNativeMethods">
            <summary>
            Declares native methods calls for security context-related win32 functions.
            </summary>
        </member>
        <member name="M:NSspi.Contexts.ContextNativeMethods.SafeEncryptMessage(NSspi.Contexts.SafeContextHandle,System.Int32,NSspi.Buffers.SecureBufferAdapter,System.Int32)">
            <summary>
            Safely invokes the native EncryptMessage function, making sure that handle ref counting is
            performed in a proper CER.
            </summary>
            <param name="handle"></param>
            <param name="qualityOfProtection"></param>
            <param name="bufferAdapter"></param>
            <param name="sequenceNumber"></param>
            <returns></returns>
        </member>
        <member name="M:NSspi.Contexts.ContextNativeMethods.SafeDecryptMessage(NSspi.Contexts.SafeContextHandle,System.Int32,NSspi.Buffers.SecureBufferAdapter,System.Int32)">
            <summary>
            Safely invokes the native DecryptMessage function, making sure that handle ref counting is
            performed in a proper CER.
            </summary>
            <param name="handle"></param>
            <param name="qualityOfProtection"></param>
            <param name="bufferAdapter"></param>
            <param name="sequenceNumber"></param>
            <returns></returns>
        </member>
        <member name="M:NSspi.Contexts.ContextNativeMethods.SafeMakeSignature(NSspi.Contexts.SafeContextHandle,System.Int32,NSspi.Buffers.SecureBufferAdapter,System.Int32)">
            <summary>
            Safely invokes the native MakeSignature function, making sure that handle ref counting is
            performed in a proper CER.
            </summary>
            <param name="handle"></param>
            <param name="qualityOfProtection"></param>
            <param name="adapter"></param>
            <param name="sequenceNumber"></param>
            <returns></returns>
        </member>
        <member name="M:NSspi.Contexts.ContextNativeMethods.SafeVerifySignature(NSspi.Contexts.SafeContextHandle,System.Int32,NSspi.Buffers.SecureBufferAdapter,System.Int32)">
            <summary>
            Safely invokes the native VerifySignature function, making sure that handle ref counting is
            performed in a proper CER.
            </summary>
            <param name="handle"></param>
            <param name="qualityOfProtection"></param>
            <param name="adapter"></param>
            <param name="sequenceNumber"></param>
            <returns></returns>
        </member>
        <member name="T:NSspi.Contexts.SecPkgContext_Sizes">
            <summary>
            Stores the result of a context query for the context's buffer sizes.
            </summary>
        </member>
        <member name="T:NSspi.Contexts.SecPkgContext_String">
            <summary>
            Stores the result of a context query for a string-valued context attribute.
            </summary>
        </member>
        <member name="T:NSspi.Contexts.ContextQueryAttrib">
            <summary>
            Defines the types of queries that can be performed with QueryContextAttribute.
            Each query has a different result buffer.
            </summary>
        </member>
        <member name="F:NSspi.Contexts.ContextQueryAttrib.Sizes">
            <summary>
            Queries the buffer size parameters when performing message functions, such
            as encryption, decryption, signing and signature validation.
            </summary>
            <remarks>
            Results for a query of this type are stored in a Win32 SecPkgContext_Sizes structure.
            </remarks>
        </member>
        <member name="F:NSspi.Contexts.ContextQueryAttrib.Names">
            <summary>
            Queries the context for the name of the user assocated with a security context.
            </summary>
            <remarks>
            Results for a query of this type are stored in a Win32 SecPkgContext_Name structure.
            </remarks>
        </member>
        <member name="F:NSspi.Contexts.ContextQueryAttrib.Authority">
            <summary>
            Queries the name of the authenticating authority for the security context.
            </summary>
            <remarks>
            Results for a query of this type are stored in a Win32 SecPkgContext_Authority structure.
            </remarks>
        </member>
        <member name="F:NSspi.Contexts.ContextQueryAttrib.SessionKey">
            <summary>
            Queries the context for it's neogtiated SessionKey
            </summary>
            <remarks>
            Results for a query of this type are stored in a Win32 SecPkgContext_SessionKey structure
            </remarks>
        </member>
        <member name="T:NSspi.Contexts.ImpersonationHandle">
             <summary>
             Represents impersonation performed on a server on behalf of a client.
             </summary>
             <remarks>
             The handle controls the lifetime of impersonation, and will revert the impersonation
             if it is disposed, or if it is finalized ie by being leaked and garbage collected.
            
             If the handle is accidentally leaked while operations are performed on behalf of the user,
             impersonation may be reverted at any arbitrary time, perhaps during those operations.
             This may lead to operations being performed in the security context of the server,
             potentially leading to security vulnerabilities.
             </remarks>
        </member>
        <member name="M:NSspi.Contexts.ImpersonationHandle.#ctor(NSspi.Contexts.ServerContext)">
            <summary>
            Initializes a new instance of the ImpersonationHandle. Does not perform impersonation.
            </summary>
            <param name="server">The server context that is performing impersonation.</param>
        </member>
        <member name="M:NSspi.Contexts.ImpersonationHandle.Dispose">
            <summary>
            Reverts the impersonation.
            </summary>
        </member>
        <member name="T:NSspi.Contexts.SafeContextHandle">
            <summary>
            Captures an unmanaged security context handle.
            </summary>
        </member>
        <member name="T:NSspi.Contexts.ServerContext">
            <summary>
            Represents a security context used in a server role.
            </summary>
        </member>
        <member name="M:NSspi.Contexts.ServerContext.#ctor(NSspi.Credentials.Credential,NSspi.Contexts.ContextAttrib)">
            <summary>
            Performs basic initialization of a new instance of the ServerContext class. The ServerContext
            is not ready for message manipulation until a security context has been established with a client.
            </summary>
            <param name="cred"></param>
            <param name="requestedAttribs"></param>
        </member>
        <member name="P:NSspi.Contexts.ServerContext.SupportsImpersonate">
            <summary>
            Whether or not the server can impersonate an authenticated client.
            </summary>
            <remarks>
            This depends on the security package that was used to create the server and client's credentials.
            </remarks>
        </member>
        <member name="M:NSspi.Contexts.ServerContext.AcceptToken(System.Byte[],System.Byte[]@)">
             <summary>
             Performs and continues the authentication cycle.
             </summary>
             <remarks>
             This method is performed iteratively to continue and end the authentication cycle with the
             client. Each stage works by acquiring a token from one side, presenting it to the other side
             which in turn may generate a new token.
            
             The cycle typically starts and ends with the client. On the first invocation on the client,
             no server token exists, and null is provided in its place. The client returns its status, providing
             its output token for the server. The server accepts the clients token as input and provides a
             token as output to send back to the client. This cycle continues until the server and client
             both indicate, typically, a SecurityStatus of 'OK'.
             </remarks>
             <param name="clientToken">The most recently received token from the client.</param>
             <param name="nextToken">The servers next authentication token in the cycle, that must
             be sent to the client.</param>
             <returns>A status message indicating the progression of the authentication cycle.
             A status of 'OK' indicates that the cycle is complete, from the servers's perspective. If the nextToken
             is not null, it must be sent to the client.
             A status of 'Continue' indicates that the output token should be sent to the client and
             a response should be anticipated.</returns>
        </member>
        <member name="M:NSspi.Contexts.ServerContext.ImpersonateClient">
             <summary>
             Changes the current thread's security context to impersonate the user of the client.
             </summary>
             <remarks>
             Requires that the security package provided with the server's credentials, as well as the
             client's credentials, support impersonation.
            
             Currently, only one thread may initiate impersonation per security context. Impersonation may
             follow threads created by the initial impersonation thread, however.
             </remarks>
             <returns>A handle to capture the lifetime of the impersonation. Dispose the handle to revert
             impersonation. If the handle is leaked, the impersonation will automatically revert at a
             non-deterministic time when the handle is finalized by the Garbage Collector.</returns>
        </member>
        <member name="M:NSspi.Contexts.ServerContext.RevertImpersonate">
            <summary>
            Called by the ImpersonationHandle when it is released, either by disposale or finalization.
            </summary>
        </member>
        <member name="T:NSspi.Credentials.NativeAuthData">
             <summary>
             Provides authentication data in native method calls.
             </summary>
             <remarks>
             Implements the 'SEC_WINNT_AUTH_IDENTITY' structure. See:
            
             https://msdn.microsoft.com/en-us/library/windows/desktop/aa380131(v=vs.85).aspx
             </remarks>
        </member>
        <member name="T:NSspi.Credentials.ClientCurrentCredential">
            <summary>
            Represents a handle to the credentials of the user running the current process, to be used to
            authenticate as a client.
            </summary>
        </member>
        <member name="M:NSspi.Credentials.ClientCurrentCredential.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ClientCurrentCredential class.
            </summary>
            <param name="package">The security package to acquire the credential handle from.</param>
        </member>
        <member name="T:NSspi.Credentials.CurrentCredential">
            <summary>
            Acquires a handle to the credentials of the user associated with the current process.
            </summary>
        </member>
        <member name="M:NSspi.Credentials.CurrentCredential.#ctor(System.String,NSspi.Credentials.CredentialUse)">
            <summary>
            Initializes a new instance of the CurrentCredential class.
            </summary>
            <param name="securityPackage">The security package to acquire the credential handle
            from.</param>
            <param name="use">The manner in which the credentials will be used - Inbound typically
            represents servers, outbound typically represent clients.</param>
        </member>
        <member name="T:NSspi.Credentials.PasswordCredential">
            <summary>
            Represents credentials acquired by providing a username, password, and domain.
            </summary>
        </member>
        <member name="M:NSspi.Credentials.PasswordCredential.#ctor(System.String,System.String,System.String,System.String,NSspi.Credentials.CredentialUse)">
            <summary>
            Initializes a new instance of the PasswordCredential class.
            </summary>
            <remarks>
            It is possible to acquire a valid handle to credentials that do not provide a valid
            username-password combination. The username and password are not validation until the
            authentication cycle begins.
            </remarks>
            <param name="domain">The domain to authenticate to.</param>
            <param name="username">The username of the user to authenticate as.</param>
            <param name="password">The user's password.</param>
            <param name="secPackage">The SSPI security package to create credentials for.</param>
            <param name="use">
            Specify inbound when acquiring credentials for a server; outbound for a client.
            </param>
        </member>
        <member name="T:NSspi.Credentials.ServerCurrentCredential">
            <summary>
            Represents a handle to the credentials of the user running the current process, to be used to
            authenticate as a server.
            </summary>
        </member>
        <member name="M:NSspi.Credentials.ServerCurrentCredential.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ServerCredential class, acquiring credentials from
            the current thread's security context.
            </summary>
            <param name="package">The name of the security package to obtain credentials from.</param>
        </member>
        <member name="T:NSspi.Credentials.Credential">
            <summary>
            Provides access to the pre-existing credentials of a security principle.
            </summary>
        </member>
        <member name="F:NSspi.Credentials.Credential.disposed">
            <summary>
            Whether the Credential has been disposed.
            </summary>
        </member>
        <member name="F:NSspi.Credentials.Credential.securityPackage">
            <summary>
            The name of the security package that controls the credential.
            </summary>
        </member>
        <member name="F:NSspi.Credentials.Credential.safeCredHandle">
            <summary>
            A safe handle to the credential's handle.
            </summary>
        </member>
        <member name="F:NSspi.Credentials.Credential.expiry">
            <summary>
            The UTC time the credentials expire.
            </summary>
        </member>
        <member name="M:NSspi.Credentials.Credential.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Credential class.
            </summary>
            <param name="package">The security package to acquire the credential from.</param>
        </member>
        <member name="P:NSspi.Credentials.Credential.PackageInfo">
            <summary>
            Gets metadata for the security package associated with the credential.
            </summary>
        </member>
        <member name="P:NSspi.Credentials.Credential.SecurityPackage">
            <summary>
            Gets the name of the security package that owns the credential.
            </summary>
        </member>
        <member name="P:NSspi.Credentials.Credential.PrincipleName">
            <summary>
            Returns the User Principle Name of the credential. Depending on the underlying security
            package used by the credential, this may not be the same as the Down-Level Logon Name
            for the user.
            </summary>
        </member>
        <member name="P:NSspi.Credentials.Credential.Expiry">
            <summary>
            Gets the UTC time the credentials expire.
            </summary>
        </member>
        <member name="P:NSspi.Credentials.Credential.Handle">
            <summary>
            Gets a handle to the credential.
            </summary>
        </member>
        <member name="M:NSspi.Credentials.Credential.Dispose">
            <summary>
            Releases all resources associated with the credential.
            </summary>
        </member>
        <member name="M:NSspi.Credentials.CredentialNativeMethods.QueryCredentialsAttribute_Name(NSspi.RawSspiHandle@,NSspi.Credentials.CredentialQueryAttrib,NSspi.Credentials.QueryNameAttribCarrier@)">
            <summary>
            The overload of the QueryCredentialsAttribute method that is used for querying the name attribute.
            In this call, it takes a void* to a structure that contains a wide char pointer. The wide character
            pointer is allocated by the SSPI api, and thus needs to be released by a call to FreeContextBuffer().
            </summary>
            <param name="credentialHandle"></param>
            <param name="attributeName"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NSspi.Credentials.CredentialQueryAttrib">
            <summary>
            Identifies credential query types.
            </summary>
        </member>
        <member name="F:NSspi.Credentials.CredentialQueryAttrib.Names">
            <summary>
            Queries the credential's principle name.
            </summary>
        </member>
        <member name="T:NSspi.Credentials.CredentialUse">
            <summary>
            Indicates the manner in which a credential will be used for SSPI authentication.
            </summary>
        </member>
        <member name="F:NSspi.Credentials.CredentialUse.Inbound">
            <summary>
            The credentials will be used for establishing a security context with an inbound request, eg,
            the credentials will be used by a server building a security context with a client.
            </summary>
        </member>
        <member name="F:NSspi.Credentials.CredentialUse.Outbound">
            <summary>
            The credentials will be used for establishing a security context as an outbound request,
            eg, the credentials will be used by a client to build a security context with a server.
            </summary>
        </member>
        <member name="F:NSspi.Credentials.CredentialUse.Both">
            <summary>
            The credentials may be used to to either build a client's security context or a server's
            security context.
            </summary>
        </member>
        <member name="T:NSspi.Credentials.QueryNameAttribCarrier">
            <summary>
            Stores the result from a query of a credential's principle name.
            </summary>
        </member>
        <member name="F:NSspi.Credentials.QueryNameAttribCarrier.Name">
            <summary>
            A pointer to a null-terminated ascii-encoded containing the principle name
            associated with a credential
            </summary>
        </member>
        <member name="T:NSspi.Credentials.SafeCredentialHandle">
            <summary>
            Provides a managed handle to an SSPI credential.
            </summary>
        </member>
        <member name="T:NSspi.SecPkgInfo">
            <summary>
            Stores information about a particular security package.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgInfo.Capabilities">
            <summary>
            The packages capabilities and options.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgInfo.Version">
            <summary>
            The package's version number.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgInfo.RpcId">
            <summary>
            The package's Id when used in RPC contexts.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgInfo.MaxTokenLength">
            <summary>
            The maximum size, in bytes, of tokens generated by the package.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgInfo.Name">
            <summary>
            The human-readable name of the package.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgInfo.Comment">
            <summary>
            A short description of the package.
            </summary>
        </member>
        <member name="T:NSspi.SecPkgCapability">
            <summary>
            Describes the capabilities of a security package.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.Integrity">
            <summary>
            Whether the package supports generating messages with integrity information. Required for MakeSignature and VerifySignature.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.Privacy">
            <summary>
            Whether the package supports generating encrypted messages. Required for EncryptMessage and DecryptMessage.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.TokenOnly">
            <summary>
            Whether the package uses any other buffer information than token buffers.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.Datagram">
            <summary>
            Whether the package supports datagram-style authentication.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.Connection">
            <summary>
            Whether the package supports creating contexts with connection semantics
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.MultiLeg">
            <summary>
            Multiple legs are neccessary for authentication.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.ClientOnly">
            <summary>
            Server authentication is not supported.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.ExtendedError">
            <summary>
            Supports extended error handling facilities.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.Impersonation">
            <summary>
            Supports client impersonation on the server.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.AcceptWin32Name">
            <summary>
            Understands Windows princple and target names.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.Stream">
            <summary>
            Supports stream semantics
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.Negotiable">
            <summary>
            Package may be used by the Negiotiate meta-package.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.GssCompatible">
            <summary>
            Compatible with GSS.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.Logon">
            <summary>
            Supports LsaLogonUser
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.AsciiBuffers">
            <summary>
            Token buffers are in Ascii format.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.Fragment">
            <summary>
            Supports separating large tokens into multiple buffers.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.MutualAuth">
            <summary>
            Supports mutual authentication between a client and server.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.Delegation">
            <summary>
            Supports credential delegation from the server to a third context.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.ReadOnlyChecksum">
            <summary>
            Supports calling EncryptMessage with the read-only-checksum flag, which protects data only
            with a checksum and does not encrypt it.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.RestrictedTokens">
            <summary>
            Whether the package supports handling restricted tokens, which are tokens derived from existing tokens
            that have had restrictions placed on them.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.ExtendsNego">
            <summary>
            Extends the negotiate package; only one such package may be registered at any time.
            </summary>
        </member>
        <member name="F:NSspi.SecPkgCapability.Negotiable2">
            <summary>
            This package is negotiated by the package of type ExtendsNego.
            </summary>
        </member>
        <member name="T:NSspi.PackageSupport">
            <summary>
            Queries information about security packages.
            </summary>
        </member>
        <member name="M:NSspi.PackageSupport.GetPackageCapabilities(System.String)">
            <summary>
            Returns the properties of the named package.
            </summary>
            <param name="packageName">The name of the package.</param>
            <returns></returns>
        </member>
        <member name="M:NSspi.PackageSupport.EnumeratePackages">
            <summary>
            Returns a list of all known security package providers and their properties.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NSspi.PackageNames">
            <summary>
            Provides canonical names for security pacakges.
            </summary>
        </member>
        <member name="F:NSspi.PackageNames.Negotiate">
            <summary>
            Indicates the Negotiate security package.
            </summary>
        </member>
        <member name="F:NSspi.PackageNames.Kerberos">
            <summary>
            Indicates the Kerberos security package.
            </summary>
        </member>
        <member name="F:NSspi.PackageNames.Ntlm">
            <summary>
            Indicates the NTLM security package.
            </summary>
        </member>
        <member name="T:NSspi.Buffers.SecureBufferInternal">
            <summary>
            Represents a native SecureBuffer structure, which is used for communicating
            buffers to the native APIs.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferInternal.Count">
            <summary>
            When provided to the native API, the total number of bytes available in the buffer.
            On return from the native API, the number of bytes that were filled or used by the
            native API.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferInternal.Type">
            <summary>
            The type or purpose of the buffer.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferInternal.Buffer">
            <summary>
            An pointer to a pinned byte[] buffer.
            </summary>
        </member>
        <member name="T:NSspi.Buffers.SecureBuffer">
             <summary>
             Stores buffers to provide tokens and data to the native SSPI APIs.
             </summary>
             <remarks>The buffer is translated into a SecureBufferInternal for the actual call.
             To keep the call setup code simple, and to centralize the buffer pinning code,
             this class stores and returns buffers as regular byte arrays. The buffer
             pinning support code in SecureBufferAdapter handles conversion to SecureBufferInternal
             for pass to the managed api, as well as pinning relevant chunks of memory.
            
             Furthermore, the native API may not use the entire buffer, and so a mechanism
             is needed to communicate the usage of the buffer separate from the length
             of the buffer.</remarks>
        </member>
        <member name="M:NSspi.Buffers.SecureBuffer.#ctor(System.Byte[],NSspi.Buffers.BufferType)">
            <summary>
            Initializes a new instance of the SecureBuffer class.
            </summary>
            <param name="buffer">The buffer to wrap.</param>
            <param name="type">The type or purpose of the buffer, for purposes of
            invoking the native API.</param>
        </member>
        <member name="P:NSspi.Buffers.SecureBuffer.Type">
            <summary>
            The type or purposes of the API, for invoking the native API.
            </summary>
        </member>
        <member name="P:NSspi.Buffers.SecureBuffer.Buffer">
            <summary>
            The buffer to provide to the native API.
            </summary>
        </member>
        <member name="P:NSspi.Buffers.SecureBuffer.Length">
            <summary>
            The number of elements that were actually filled or used by the native API,
            which may be less than the total length of the buffer.
            </summary>
        </member>
        <member name="T:NSspi.Buffers.SecureBufferAdapter">
             <summary>
             Prepares SecureBuffers for providing them to native API calls.
             </summary>
             <remarks>
             The native APIs consume lists of buffers, with each buffer indicating its type or purpose.
            
             The buffers themselves are simple byte arrays, and the native APIs consume arrays of buffers.
            
             Since winapi calling convention, perhaps as an extension of C calling convention, does not
             provide a standard convention means of communicating the length of any array, custom structures
             must be created to carry the buffer length and usage.
            
             Not only does the API need to know how long each buffer is, and how long the array of buffers is,
             it needs to communicate back how much of each buffer was filled; we may provide it a token buffer
             that is 12288 bytes long, but it might only use 125 bytes of that, which we need a way of knowing.
            
             As a result of this, the API requires byte arrays to be carried in structs that are natively known as
             SecureBuffers (known as SecureBufferInternal in this project), and then arrays of SecureBuffers are
             carried in a SecureBufferDescriptor structure.
            
             As such, this class has to do a significant amount of marshaling work just to get the buffers back and
             forth to the native APIs.
               * We have to pin all buffers
               * We have to pin the array of buffers
               * We have to obtain IntPtr handles to each of the buffers and to the array of buffers.
               * Since we provide EasyToUse SecureBuffer classes from the rest of the project, but we
                 provide SecureBufferInternal structures from the native API, we have to copy back values
                 from the SecureBufferInternal structs to our SecureBuffer class.
            
             To make this class easy to use, it accepts either one or many buffers as its constructor; and
             implements IDisposable to know when to marshal values back from the unmanaged structures and to
             release pinned handles.
            
             Additionally, in case the adapter is leaked without disposing, the adapter implements a Critical
             Finalizer, to ensure that the GCHandles are released, else we will permanently pin handles.
            
             The typical flow is to take one or many buffers; create and fill the neccessary unmanaged structures;
             pin memory; acquire the IntPtr handles; let the caller access the top-level IntPtr representing
             the SecureBufferDescriptor, to provide to the native APIs; wait for the caller to invoke the native
             API; wait for the caller to invoke our Dispose; marshal back any data from the native structures
             (buffer write counts); release all GCHandles to unpin memory.
            
             The total descriptor structure is as follows:
             |-- Descriptor handle
                 |-- Array of buffers
                     |-- Buffer 1
                     |-- Buffer 2
                     ...
                     |-- Buffer N.
            
             Each object in that structure must be pinned and passed as an IntPtr to the native APIs.
             All this to pass what boils down to a List of byte arrays..
             </remarks>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferAdapter.disposed">
            <summary>
            Whether the adapter has already been disposed.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferAdapter.buffers">
            <summary>
            The list of mananged SecureBuffers the caller provided to us.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferAdapter.descriptorHandle">
            <summary>
            The top level handle representing the entire descriptor.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferAdapter.bufferCarrierHandle">
            <summary>
            The handle representing the array of buffers.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferAdapter.bufferHandles">
            <summary>
            The handles representing each actual buffer.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferAdapter.descriptor">
            <summary>
            The native buffer descriptor
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferAdapter.bufferCarrier">
            <summary>
            An array of the native buffers.
            </summary>
        </member>
        <member name="M:NSspi.Buffers.SecureBufferAdapter.#ctor(NSspi.Buffers.SecureBuffer)">
            <summary>
            Initializes a SecureBufferAdapter to carry a single buffer to the native api.
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:NSspi.Buffers.SecureBufferAdapter.#ctor(System.Collections.Generic.IList{NSspi.Buffers.SecureBuffer})">
            <summary>
            Initializes the SecureBufferAdapter to carry a list of buffers to the native api.
            </summary>
            <param name="buffers"></param>
        </member>
        <member name="P:NSspi.Buffers.SecureBufferAdapter.Handle">
            <summary>
            Gets the top-level pointer to the secure buffer descriptor to pass to the native API.
            </summary>
        </member>
        <member name="M:NSspi.Buffers.SecureBufferAdapter.Dispose">
            <summary>
            Completes any buffer passing marshaling and releases all resources associated with the adapter.
            </summary>
        </member>
        <member name="M:NSspi.Buffers.SecureBufferAdapter.Dispose(System.Boolean)">
            <summary>
            Completes any buffer passing marshaling and releases all resources associated with the adapter.
            This may be called by the finalizer, or by the regular Dispose method. In the case of the finalizer,
            we've been leaked and there's no point in attempting to marshal back data from the native structures,
            nor should we anyway since they may be gone.
            </summary>
            <param name="disposing">Whether Dispose is being called.</param>
        </member>
        <member name="T:NSspi.Buffers.SecureBufferDataRep">
            <summary>
            Describes how a buffer's opaque internals should be stored, with regards to byte ordering.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferDataRep.Native">
            <summary>
            Buffers internals are to be stored in the machine native byte order, which will change depending on
            what machine generated the buffer.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferDataRep.Network">
            <summary>
            Buffers are stored in network byte ordering, that is, big endian format.
            </summary>
        </member>
        <member name="T:NSspi.Buffers.SecureBufferDescInternal">
            <summary>
            Represents the native layout of the secure buffer descriptor that is provided directly
            to native API calls.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferDescInternal.Version">
            <summary>
            The buffer structure version.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferDescInternal.NumBuffers">
            <summary>
            The number of buffers represented by this descriptor.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferDescInternal.Buffers">
            <summary>
            A pointer to a array of buffers, where each buffer is a byte[].
            </summary>
        </member>
        <member name="F:NSspi.Buffers.SecureBufferDescInternal.ApiVersion">
            <summary>
            Indicates the buffer structure version supported by this structure. Always 0.
            </summary>
        </member>
        <member name="T:NSspi.Buffers.BufferType">
            <summary>
            Describes the type and purpose of a secure buffer passed to the native API.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.BufferType.Empty">
            <summary>
            The buffer is empty.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.BufferType.Data">
            <summary>
            The buffer contains message data. Message data can be plaintext or cipher text data.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.BufferType.Token">
            <summary>
            The buffer contains opaque authentication token data.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.BufferType.Parameters">
            <summary>
            The buffer contains parameters specific to the security package.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.BufferType.Missing">
            <summary>
            The buffer placeholder indicating that some data is missing.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.BufferType.Extra">
            <summary>
            The buffer passed to an API call contained more data than was necessary for completing the action,
            such as the case when a streaming-mode connection that does not preserve message bounders, such as TCP
            is used as the transport. The extra data is returned back to the caller in a buffer of this type.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.BufferType.Trailer">
            <summary>
            The buffer contains a security data trailer, such as a message signature or marker, or framing data.
            </summary>
        </member>
        <member name="F:NSspi.Buffers.BufferType.Header">
            <summary>
            The buffer contains a security data header, such as a message signature, marker, or framing data.
            </summary>
        </member>
        <member name="T:NSspi.SecurityStatus">
            <summary>
            Defines the results of invoking the SSPI api.
            </summary>
        </member>
        <member name="F:NSspi.SecurityStatus.OK">
            <summary>
            The request completed successfully
            </summary>
        </member>
        <member name="F:NSspi.SecurityStatus.ContinueNeeded">
            <summary>
            The token returned by the context needs to be provided to the cooperating party
            to continue construction of the context.
            </summary>
        </member>
        <member name="F:NSspi.SecurityStatus.CompleteNeeded">
            <summary>
            Occurs after a client calls InitializeSecurityContext to indicate that the client
            must call CompleteAuthToken.
            </summary>
        </member>
        <member name="F:NSspi.SecurityStatus.CompAndContinue">
            <summary>
            Occurs after a client calls InitializeSecurityContext to indicate that the client
            must call CompleteAuthToken and pass the result to the server.
            </summary>
        </member>
        <member name="F:NSspi.SecurityStatus.ContextExpired">
            <summary>
            An attempt to use the context was performed after the context's expiration time elapsed.
            </summary>
        </member>
        <member name="F:NSspi.SecurityStatus.PackageNotFound">
            <summary>
            No security provider package was found with the given name.
            </summary>
        </member>
        <member name="F:NSspi.SecurityStatus.InvalidToken">
            <summary>
            A token was provided that contained incorrect or corrupted data.
            </summary>
        </member>
        <member name="F:NSspi.SecurityStatus.NoImpersonation">
            <summary>
            Impersonation is not supported.
            </summary>
        </member>
        <member name="F:NSspi.SecurityStatus.IncompleteMessage">
            <summary>
            The buffer provided to an SSPI API call contained a message that was not complete.
            </summary>
            <remarks>
            This occurs regularly with SSPI contexts that exchange data using a streaming context,
            where the data returned from the streaming communications channel, such as a TCP socket,
            did not contain the complete message.
            Similarly, a streaming channel may return too much data, in which case the API function
            will indicate success, but will save off the extra, unrelated data in a buffer of
            type 'extra'.
            </remarks>
        </member>
        <member name="T:NSspi.SecurityStatusExtensions">
            <summary>
            Provides extension methods for the SecurityStatus enumeration.
            </summary>
        </member>
        <member name="M:NSspi.SecurityStatusExtensions.IsError(NSspi.SecurityStatus)">
            <summary>
            Returns whether or not the status represents an error.
            </summary>
            <param name="status"></param>
            <returns>True if the status represents an error condition.</returns>
        </member>
        <member name="T:NSspi.SSPIException">
            <summary>
            The exception that is thrown when a problem occurs hwen using the SSPI system.
            </summary>
        </member>
        <member name="M:NSspi.SSPIException.#ctor(System.String,NSspi.SecurityStatus)">
            <summary>
            Initializes a new instance of the SSPIException class with the given message and status.
            </summary>
            <param name="message">A message explaining what part of the system failed.</param>
            <param name="errorCode">The error code observed during the failure.</param>
        </member>
        <member name="M:NSspi.SSPIException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the SSPIException class from serialization data.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:NSspi.SSPIException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serializes the exception.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:NSspi.SSPIException.ErrorCode">
            <summary>
            The error code that was observed during the SSPI call.
            </summary>
        </member>
        <member name="P:NSspi.SSPIException.Message">
            <summary>
            A human-readable message indicating the nature of the exception.
            </summary>
        </member>
        <member name="T:NSspi.RawSspiHandle">
             <summary>
             Represents the raw structure for any handle created for the SSPI API, for example, credential
             handles, context handles, and security package handles. Any SSPI handle is always the size
             of two native pointers.
             </summary>
             <remarks>
             The documentation for SSPI handles can be found here:
             http://msdn.microsoft.com/en-us/library/windows/desktop/aa380495(v=vs.85).aspx
            
             This class is not reference safe - if used directly, or referenced directly, it may be leaked,
             or subject to finalizer races, or any of the hundred of things SafeHandles were designed to fix.
             Do not directly use this class - use only though SafeHandle wrapper objects. Any reference needed
             to this handle for performing work (InitializeSecurityContext, eg) should be performed a CER
             that employs handle reference counting across the native API invocation.
             </remarks>
        </member>
        <member name="M:NSspi.RawSspiHandle.IsZero">
            <summary>
            Returns whether or not the handle is set to the default, empty value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NSspi.RawSspiHandle.SetInvalid">
            <summary>
            Sets the handle to an invalid value.
            </summary>
            <remarks>
            This method is executed in a CER during handle release.
            </remarks>
        </member>
        <member name="T:NSspi.SafeSspiHandle">
            <summary>
            Safely encapsulates a raw handle used in the SSPI api.
            </summary>
        </member>
        <member name="T:NSspi.TimeStamp">
            <summary>
            Represents a Windows API Timestamp structure, which stores time in units of 100 nanosecond
            ticks, counting from January 1st, year 1601 at 00:00 UTC. Time is stored as a 64-bit value.
            </summary>
        </member>
        <member name="F:NSspi.TimeStamp.time">
            <summary>
            Stores the time value. Infinite times are often represented as values near, but not exactly
            at the maximum signed 64-bit 2's complement value.
            </summary>
        </member>
        <member name="M:NSspi.TimeStamp.ToDateTime">
            <summary>
            Converts the TimeStamp to an equivalant DateTime object. If the TimeStamp represents
            a value larger than DateTime.MaxValue, then DateTime.MaxValue is returned.
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
